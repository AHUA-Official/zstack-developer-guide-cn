# 前言

ZStack发布以来，已经得到越来越多的开源云计算爱好者的关注，不少公司和开发者也开始基于ZStack做二次开发。本文档详细介绍了ZStack的技术实现细节，为开发者提供第一手的ZStack开发资料. 

虽然该文档是以ZStack的设计与实现为主题的，但其覆盖的大型程序设计的方方面面会引出非常多有意思的话题，例如“什么样的架构能够承担百万级代码？”、“如何在一个全异步的程序中实现exception safe？”、“进程内微服务架构是个什么鬼？”、“在Java中，为什么使用interface的funcional style编程比使用lambda更灵活？” ... 诸如此类。这都是我们在开发ZStack的过程中通过不断实践总结下来的经验，也能被一般大型程序所借鉴。

## 围绕metadata（元数据）而生

几年前在跟Darren Shepherd（前同事，现容器初创企业Rancher CTO）有一次聊天，他提到IaaS管控软件（例如你们熟悉的OpenStack，CloudStack，还有ZStack）的本质是metadata管理软件，我们所做的一切，不过是尽力维护数据中心各种物理设备和虚拟设备的元数据与中心数据库的一致。虽然该观点不一定是Darren首创，但他确实非常准确的指出了编排软件的本质。无论媒体或从业者把云描述的如何神奇，冠以各种高大上的词汇，例如“数据中心操作系统”、“云OS”，在程序员眼中，编排软件（无论是IaaS还是容器）无非是大型的配置管理程序，它根据用户的指令配置数据中心的虚拟、物理资源，将它们的元数据设置到合适的状态，并尽力在数据库中维护这些元数据的一致性。

你已经注意到我多次用了“尽力”二字。是的，在一个大型分布式系统中维护元数据的一致性是非常难的，在后面的章节中，你们将看到ZStack为此所做的努力。

>**什么是元数据**
>
>元数据（metadata）的通常定义是：*data that provides information about other data*，即用来描述其它数据的数据。在IaaS的语境中，元数据用来描述数据中心中的物理设备、虚拟设备的状态。在后面的内容中，“状态改变”即指“元数据改变”。

我们用一个例子来说明这种状态的改变，以及维护状态一致性的难点。当用户启动一个虚拟机时，系统中通常会发生如下步骤：

1. 调度算法分配物理机 
2. 在主存储上创建虚拟磁盘
3. 配置网络，设置DHCP、DNS等网络服务
4. 一切都准备好后，在物理机上新建虚拟机

在这个例子中，创建虚拟磁盘会改变存储系统的状态（新建了一个文件/块设备，可用磁盘容量减少），配置网络改变网络系统的状态（占用了新的IP地址，配置了DHCP、DNS等条目），新建虚拟机改变计算系统的状态（物理机上出现一个新的虚拟机）。这一切的改变都需要被记录在数据中，否则编排软件无法得知系统状态。当某个步骤发生错误时，例如在最后一步虚拟机创建失败了，前面步骤所执行的操作就应该回滚恢复之前的状态，否则系统状态就会跟数据库状态不一致。当这种不一致累积到一定程度的时，就会最终导致系统崩溃。

## 架构的选择：没有完美

编排软件通常也是系统集成软件，其特性是粘合各种不同的、独立的子系统。

>In information technology, systems integration is the process of linking together different computing systems and software applications physically or functionally, to act as a coordinated whole.

从定义上就可以知道，程序员是很难在在编写此类软件时获得愉悦感的。每个子系统都不受你控制，他们有的可能不提供API，有的是20年前的设计，有的BUG丛生，有的干脆就是猪设计。你要做的一切就是不断的粘合，不断想workaround，为了让整个系统能够完整而正常的工作，如果做的更好一点，健壮的工作。所以你明白为啥会没有愉悦感了，因为你总是在为别人的错误埋单，即使你已经在脑海里抱怨了一百遍：It's not my fault, it's the fucking system not having APIs，你还是得找出一条路让它能够跟你的程序集成起来。奋斗吧少年！含着眼泪帮别人把屁股擦完，写出高质量的code吧！

所以在动手写第一行code之前，我花了数月的时间来思考架构。如你所知，我是CloudStack早起员工，在加入Cloud.com一年之后，我已经完成了诸如Overlay Network on Openvswitch、Baremetal as a Service等项目，对CloudStack的架构了然于心。这并不是说我很牛，而是CloudStack的代码耦合的很紧，如铁板一块，如果不至上而下的了解清楚所有细节，是无法完成老板交给我的任务的。

2011年时Citrix收购了Cloud.com，OpenStack也在此时声名鹊起。作为OpenStack的早期贡献者，Citrix内部展开了一场关于真理的大讨论：继续投入OpenStack社区还是推刚2.3亿美金买来的CloudStack上位？老美的逻辑你永远不懂，刚花2.3亿美金买了个公司，不到一个月就开始讨论是不是刚买的东西不要了，把人全部转去做另一个开源项目。我当时都觉得人才真是太值钱了，2.3亿美金啊！后来回到天朝创业后我才知道，这事在天朝只要3000万美金就足够了，把下面干事的人全挖过来。扯远了。由于当时的大讨论很激烈，老大要求几位主架构师一个月内出一份OpenStack和CloudStack的技术对比报告，以供圣断。几位架构师都是CloudStack的创始工程师，结果可想而知，但平心而论，2011年的OpenStack还太早期，很多IaaS必备的功能都不齐全，Citrix选CloudStack从技术上讲并没有什么错误。也是接这个大讨论的机会，我花了大量时间学习研究OpenStack。当时它完全不同于CloudStack的架构设计让我觉得很新奇，我也跟打了鸡血似的读了很多关于SOA、关于微服务架构的书籍，像什么《Enterprise Integration Patterns》、《Service Oriented Architecture》等，还有一堆《xxx In Actions》的工具书。所以我对OpenStack的基础架构设计还是很了解的。








