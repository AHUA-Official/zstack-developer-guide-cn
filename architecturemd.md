# 进程内微服务架构
## 总览

我们用一张图开始这章的内容。

![进程内微服务架构](inprocess-microservices.png)

在上图中，`management node`作为一个独立的进程，是所有微服务的container，用于管理微服务的生命周期，提供统一的服务监控和HA（高可靠）等功能。图中的每一个单独的深蓝色方块都是一个独立的服务，根据功能的不同，在逻辑上归纳为：计算服务、存储服务、网络服务以及其它服务。虽然运行在同一进程中，所有服务在代码逻辑上仍然高度松耦合，服务之间通过外部消息总线通信，跟运行在独立进程中的微服务架构类似。

如果你熟悉传统微服务架构，你一定听过诸如“API Gateway”、“Self Registration”、“Client-side Delivery”、“Server-side Delivery”这样的词汇，它们在ZStack的微服务架构中都能找到，有些的实现还更为简单精巧。让你头疼的监控、高可靠、配置等诸多问题则不复存在，一切都由管理节点进程代为处理，开发人员只需要专心实现服务的业务逻辑即可。

## 要么没有，要么全有

我曾多次在技术交流中给国内主流公有云、互联网公司的技术团队讲解这个设计，收获的最多的一个问题是：如果某个服务存在性能瓶颈，在这个架构中无法对单一服务进行横向扩展。凑巧的是，提出这个问题的朋友都是来自OpenStack技术团队，可见“能够对单服务横向扩展”是OpenStack宣称的一个架构优势。

是的，在这个架构中，进程一旦启动就会加载所有服务，你不能选择性的加载一部分服务，要么没有，要么全有。你也不能对特定服务进行单独横向扩展，只能横向扩展管理节点进程，这样所有的服务都会获得相同程度的横向扩展。这听起来似乎不灵活也不合理，我已经听见你在心里这么说了。当你读到后面的章节时，你会发现在ZStack架构中，用户完全通过更改XML配置文件，实现只运行部分服务或横向扩展特定服务。但我不建议用户这么做，原因如下：

### 核心服务缺一不可

任何软件都存在一组核心模块/服务，缺少任何一个都会导致整个系统不工作，IaaS亦然。目前为止，ZStack的服务绝大多数都是核心服务，例如虚拟机服务、物理机服务、主存储服务、镜像服务等；一些非核心服务，例如搜索服务，虽然不加载也不会影响整体功能，但会极大的损伤用户体验，甚至导致某些外围组件（例如UI）不工作。这些服务缺一不可，单独部署除了增加运维的复杂度外，并不能带来任何好处。

### 扩展节点即扩展服务

当某个服务存在热点时，只需要扩展多个管理节点就会产生多份该服务的实力，用于分担压力。虽然扩展节点也会同时生成其它服务的实例，但它们不会占用任何资源（如果服务不活跃），当读到后面的线程池模型章节你就会明白。也就是说，新增加的管理节点的资源可以只被忙碌的服务消耗，其它服务虽然拥有实例，但并不做任何事情。不用担心会产生[Starvation](https://en.wikipedia.org/wiki/Starvation_(computer_science))问题，在后面的章节你会看到ZStack是全异步架构，没有资源会被阻塞忙等待。

### 横向扩展，你可能永远不需要

还记得在上一章中我们为ZStack设定的架构目标吗？要能够单节点管理数万物理机、百万级虚拟机，同时响应数万并发API，我相信这个性能指标世界上绝大多数公有云做不到。所以如果你是私有云和混合云，排除高可靠的因素，你可能永远不需要部署第二个管理节点。即使你是公有云，两个管理节点或许永远满足你对单套环境性能要求。既然如此，干嘛还纠结要横向扩展某个特定服务？

## 还是不一样

进程内微服务架构只是采用微服务架构的形式来解耦合代码，实现功能模块的高度模块化和自治化，但它并不是真正的微服务架构，它们之间的最大区别是：微服务架构是动态的，而进程内微服务架构是静态的。

微服务架构中的服务实例通常是运行在虚拟机或容器之中。实例的数量会根据系统负载情况动态变化，弹性扩展。大量的服务实例的生命周期可能是短暂的，在负载降低时会被销毁，在负载上升时又再次被创建。与之相比，进程内微服务架构中的服务实例是静态的，它们的生命周期和数量都跟管理节点进程绑定，一旦创建就一直运行。而IaaS的特性又决定管理员通常会预先创建足够多的管理节点来应对可能的负载，服务实例的数量很少会动态调整，即使有，规模也是非常小的。

这种动与静的区别导致两种架构管理服务实例的方法非常不同，相比之下，进程内微服务架构更为简单直接，而简单带来稳定。

>从某种意义上来说，进程内微服务架构中的服务特性其实更类似于传统的分布式SOA系统，服务实例运行在固定的位置（IP、端口），实例数量变动频繁，服务间预先知道对方信息并能容易的进行相互调用。为什么要叫进程内**微**架构呢？谁叫这个词今年来火呢。
